#include <vector>

#include "../Header/Test.hpp"


/**
 * Constructeur de Testing
 */
Testing::Testing(void)
{
    
}

/**
 * Constructeur de la classe Testing
 * @param argc Nombre d'arguments lors de l'appel du programme
 * @param argv Liste des arguments lors de l'appel du programme
 */
/*Testing::Testing(int argc, char** argv) 
{
    nbArg = argc;
    listArg = argv;
    
    //On trouve la commande auto/load ou help en premier
    if(nbArg>1)
        for(int i = 0;(i<END_COMMAND_T)&&(cmd==END_COMMAND_T);i++)
        {    
            //cout << listArg[1] << " vs " << command_list_t[i] << "\n\r";
            if(!strcmp(listArg[1],command_list_t[i]))
                cmd = (command_t)i;
        }
    
    // on execute le code selon le mode trouve
    switch(cmd) 
    {
        //Mode automatique
        case AUTO_SHORT:
        case AUTO_LONG:
            cout << "\n\r" << "Use automatic generated values" << "\n\n\r";
            //AutoModeConfig();
            break;
        
        //Mode lecture de donnees
        case LOAD_SHORT:
        case LOAD_LONG:
            cout << "\n\r" << "Use values loaded from a file" << "\n\n\r";
            LoadModeConfig();
            break;
        
        // Mode aide
        case HELP_SHORT:
        case HELP_LONG:
            cout << "\n\r" << "Show help" << "\n\n\r";
            break;
            
        case MANUAL_AUTO_SHORT:
        case MANUAL_AUTO_LONG:
             cout << "\n\r" << "AutoGenerated Value. Enter value manually" << "\n\n\r";
            break;
        
        case MANUAL_LOAD_SHORT:
        case MANUAL_LOAD_LONG:
             cout << "\n\r" << "Loaded Value. Enter value manually" << "\n\n\r";
             ManualLoadConfig();
            break;
            
        //Autre/erreurs
        default:
            cout << "\n\r" << "I AM ERROR" << "\n\n\r";
            break;
    }    
}*/

/**
 * Destructeur de Testing
 */
Testing::~Testing(void) 
{
    
}

/**
 * Fonction de configuration si le mode est automatique
 */
/*void Testing::AutoModeConfig(void)
{
    /*for(int j = 2; j < nbArg; j++)
    {    
        AutoModeOptionConfig(j);
    }
    cout << "\n\rN = " << N << " R = " << R << " D = " << D << "\n\r";
    cout << "OutputFile= " << outputFile << "\n\r";*/
/*    
    count=0;
    if(nbArg==11)
    {
        //cout << "\n\r" << "OK" << "\n\n\r";
        //LoadT1(listArg[2]);
        
        for(int j = 2; j < nbArg; j++)
        {    
            AutoModeOptionConfig(j);
        }
        
        LoadT2(listArg[8]);
        ResultTable = new int[K];
        
        for(int i = 0;(i<END_ALGO_T)&&(algo==END_ALGO_T);i++)
        {    
            //cout << listArg[4] << " vs " << algo_list_t[i] << "\n\r";
            if(!strcmp(listArg[9],algo_list_t[i]))
                algo = (algo_t)i;
        }
        
        switch(algo)
        {
            case HASH_SHORT: 
            case HASH_LONG:
            {    
                cout << "\n\r" << "HASH TABLE" << "\n\n\r";
                
                hashH hashy;
                for(int i = 0; i < N; i++)
                {
                    hashy.AddItem(DataTable[i],i);
                }
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = hashy.RechercheHash(SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }    
            break;
                
            case TREE_SHORT: 
            case TREE_LONG:
            {
                cout << "\n\r" << "TREE" << "\n\n\r";
                BinaryTree bin;
                for(int i =0; i<N; i++)
                {
                    bin.addnode(DataTable[i],i);
                }
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = bin.findNode(SearchTable[i]);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
                
            break;    
                
            case SEQ_SHORT: 
            case SEQ_LONG:
            {
                cout << "\n\r" << "SEQUENTIAL" << "\n\n\r";
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = RechercheSequentielle(DataTable,SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
            break;
                
            case BIN_SHORT:
            case BIN_LONG:
            {    
                int BigDataTable[N][2];
                int i;
                for (i = 0; i < N; i++)
                {
                    BigDataTable[i][0] = DataTable[i]; // Premiere rangÃ©e = clÃ©
                    BigDataTable[i][1] = i; // DeuxiÃ¨me rangÃ©e = position dans la liste non triÃ©e
                }
                
                cout << "\n\r" << "BINARY" << "\n\n\r";
                TriParFusion(BigDataTable, 0, N-1);
                
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = RechercheBinaire(BigDataTable,SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
            break;
            case OPTIMIZE_SHORT:
            case OPTIMIZE_LONG:
            {
                cout << "\n\r" << "OPTIMIZE" << "\n\n\r";
                for(int i =0; i<K; i++)
                {
                    //ResultTable[i] = RechercheSequentielle(DataTable,SearchTable[i],N);
                    ResultTable[i] = RechercheOptimisee(DataTable,SearchTable[i],N, R, D);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }  
        }
        printf("K = %i, Count = %i\n\n\r",K,count);
        SaveT3(listArg[10]);
    }
    else if(nbArg<11)
    {
        cout << "\n\r" << "Not enough argument" << "\n\n\r"; 
    }
    else
    {
        cout << "\n\r" << "Too much argument" << "\n\n\r";
    }

}*/

/**
 * Fonction qui lit les differents paramÃ¨tres necessaires 
 * pour generer les donnees automatiquement si ils sont
 * presents dans la liste d'argument
 * @param iDArg Numero du dernier argument lu 
 */
/*void Testing::AutoModeOptionConfig(int iDArg)
{
    option = END_OPTION_T;
        for(int i = 0;(i<END_OPTION_T)&&(option==END_OPTION_T);i++)
        {    
            //cout << listArg[iDArg] << " vs " << option_list_t[i] << "\n\r";
            if(!strcmp(listArg[iDArg],option_list_t[i]))
            {    
                option = (option_t)i;
                
                switch(option)
                {
                    case NBR_DATA:
                        N = atoi(listArg[iDArg+1]);
                        break;
                        
                    case RANK_DATA:
                        R = atoi(listArg[iDArg+1]);
                        break;
                        
                    case DISPERTION_RATE:
                        D = atoi(listArg[iDArg+1]);
                        break;
                        
                    default :
                        break;
                }
            }   
        }
}

void Testing::LoadModeConfig(void)
{
    count=0;
    if(nbArg==6)
    {
        //cout << "\n\r" << "OK" << "\n\n\r";
        LoadT1(listArg[2]);
        LoadT2(listArg[3]);
        ResultTable = new int[K];
        
        for(int i = 0;(i<END_ALGO_T)&&(algo==END_ALGO_T);i++)
        {    
            //cout << listArg[4] << " vs " << algo_list_t[i] << "\n\r";
            if(!strcmp(listArg[4],algo_list_t[i]))
                algo = (algo_t)i;
        }
        
        switch(algo)
        {
            case HASH_SHORT: 
            case HASH_LONG:
            {    
                cout << "\n\r" << "HASH TABLE" << "\n\n\r";
                
                hashH hashy;
                for(int i = 0; i < N; i++)
                {
                    hashy.AddItem(DataTable[i],i);
                }
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = hashy.RechercheHash(SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }    
            break;
                
            case TREE_SHORT: 
            case TREE_LONG:
            {
                cout << "\n\r" << "TREE" << "\n\n\r";
                BinaryTree bin;
                for(int i =0; i<N; i++)
                {
                    bin.addnode(DataTable[i],i);
                }
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = bin.findNode(SearchTable[i]);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
                
            break;    
                
            case SEQ_SHORT: 
            case SEQ_LONG:
            {
                cout << "\n\r" << "SEQUENTIAL" << "\n\n\r";
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = RechercheSequentielle(DataTable,SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
            break;
                
            case BIN_SHORT:
            case BIN_LONG:
            {    
                int BigDataTable[N][2];
                int i;
                for (i = 0; i < N; i++)
                {
                    BigDataTable[i][0] = DataTable[i]; // Premiere rangÃ©e = clÃ©
                    BigDataTable[i][1] = i; // DeuxiÃ¨me rangÃ©e = position dans la liste non triÃ©e
                }
                
                cout << "\n\r" << "BINARY" << "\n\n\r";
                TriParFusion(BigDataTable, 0, N-1);
                
                for(int i =0; i<K; i++)
                {
                    ResultTable[i] = RechercheBinaire(BigDataTable,SearchTable[i],N);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }
            break;
            case OPTIMIZE_SHORT:
            case OPTIMIZE_LONG:
            {
                cout << "\n\r" << "OPTIMIZE" << "\n\n\r";
                for(int i =0; i<K; i++)
                {
                    //ResultTable[i] = RechercheSequentielle(DataTable,SearchTable[i],N);
                    ResultTable[i] = RechercheOptimisee(DataTable,SearchTable[i],N, R, D);
                    if(ResultTable[i]!=-1)
                    {
                        count++;
                        //printf("%i %i %i %i \n\n\r",count,i,SearchTable[i], ResultTable[i]);
                    }
                }
            }  
        }
        printf("K = %i, Count = %i\n\n\r",K,count);
        SaveT3(listArg[5]);
    }
    else if(nbArg<6)
    {
        cout << "\n\r" << "Not enough argument" << "\n\n\r"; 
    }
    else
    {
        cout << "\n\r" << "Too much argument" << "\n\n\r";
    }
}

void Testing::ManualAutoConfig(void)
{
    
}

void Testing::ManualLoadConfig(void)
{
    int value = 0,result;
    if(nbArg==4)
    {
        //cout << "\n\r" << "OK" << "\n\n\r";
        LoadT1(listArg[2]);
        
        for(int i = 0;(i<END_ALGO_T)&&(algo==END_ALGO_T);i++)
        {    
            //cout << listArg[3] << " vs " << algo_list_t[i] << "\n\r";
            if(!strcmp(listArg[3],algo_list_t[i]))
                algo = (algo_t)i;
        }
        
        switch(algo)
        {
            case HASH_SHORT: 
            case HASH_LONG:
            {    
                cout << "\n\r" << "HASH TABLE" << "\n\n\r";
                
                hashH hashy;
                for(int i = 0; i < N; i++)
                {
                    hashy.AddItem(DataTable[i],i);
                }
                
                while(value>=0)
                {
                    cout << "Enter a value to search (or negative value to quit): ";
                    cin >> value;
                    if(cin.good())
                    {
                        if(value>=0)
                        {
                            result = hashy.RechercheHash(value,N);
                            cout << "Value :" << value << " is found in index : "<< result << endl;
                        }
                    }
                    else
                    {
                        cout << "Wrong input\n\r";
                    }
                    cin.clear();
                    cin.ignore();
                    
                }
            }    
            break;
                
            case TREE_SHORT: 
            case TREE_LONG:
            {
                cout << "\n\r" << "TREE" << "\n\n\r";
                BinaryTree bin;
                for(int i =0; i<N; i++)
                {
                    bin.addnode(DataTable[i],i);
                }

                while(value>=0)
                {
                    cout << "Enter a value to search (or negative value to quit): ";
                    cin >> value;
                    if(cin.good())
                    {
                        if(value>=0)
                        {
                            result = bin.findNode(value);
                            cout << "Value :" << value << " is found in index : "<< result << endl;
                        }
                    }
                    else
                    {
                        cout << "Wrong input\n\r";
                    }
                    cin.clear();
                    cin.ignore();
                }
            }
            break;    
                
            case SEQ_SHORT: 
            case SEQ_LONG:
            {
                cout << "\n\r" << "SEQ" << "\n\n\r";
                
                while(value>=0)
                {
                    cout << "Enter a value to search (or negative value to quit): ";
                    cin >> value;
                    if(cin.good())
                    {
                        if(value>=0)
                        {
                            result = RechercheSequentielle(DataTable,value,N);
                            cout << "Value :" << value << " is found in index : "<< result << endl;
                        }
                    }
                    else
                    {
                        cout << "Wrong input\n\r";
                    }
                    cin.clear();
                    cin.ignore();
                }
            }
            break;
                
            case BIN_SHORT:
            case BIN_LONG:
            {    
                int BigDataTable[N][2];
                int i;
                for (i = 0; i < N; i++)
                {
                    BigDataTable[i][0] = DataTable[i]; // Premiere rangee = cle
                    BigDataTable[i][1] = i; // Deuxieme rangee = position dans la liste non triee
                }
                
                cout << "\n\r" << "BINARY" << "\n\n\r";
                TriParFusion(BigDataTable, 0, N-1);
                
                while(value>=0)
                {
                    cout << "Enter a value to search (or negative value to quit): ";
                    cin >> value;
                    if(cin.good())
                    {
                        if(value>=0)
                        {
                            result = RechercheBinaire(BigDataTable,value,N);
                            cout << "Value :" << value << " is found in index : "<< result << endl;
                        }
                    }
                    else
                    {
                        cout << "Wrong input\n\r";
                    }
                    cin.clear();
                    cin.ignore();
                }
            }
            break;
            case OPTIMIZE_SHORT:
            case OPTIMIZE_LONG:
            {
                cout << "\n\r" << "OPTIMIZE" << "\n\n\r";
                
                while(value>=0)
                {
                    cout << "Enter a value to search (or negative value to quit): ";
                    cin >> value;
                    if(cin.good())
                    {
                        if(value>=0)
                        {
                            result = RechercheOptimisee(DataTable,value,N, R, D);
                            cout << "Value :" << value << " is found in index : "<< result << endl;
                        }
                    }
                    else
                    {
                        cout << "Wrong input\n\r";
                    }
                    cin.clear();
                    cin.ignore();
                }
            }
            break;  
        }
    }
    else if(nbArg<4)
    {
        cout << "\n\r" << "Not enough argument" << "\n\n\r"; 
    }
    else
    {
        cout << "\n\r" << "Too much argument" << "\n\n\r";
    }
}
*/

/**
 * Charge le fichier de données
 * @param address Adresse du fichier de données
 * @return True si le fichier est valide
 */
bool Testing::LoadT1(const char* address)
{
    FILE * textfile;
    char c;
    int index=0;
    int tmp;
    string buffer="";
    
    textfile = fopen (address,"r");
    if (textfile == NULL) 
    {
        perror ("Error opening file");
        return false;
    }
    else 
    {
        do 
        {
            c = fgetc (textfile);
            if(c != EOF)
            {
                if(c>='0'&& c<='9')
                {
                    buffer+=c;
                }
                else
                {
                    if(buffer!="")
                    {
                        sscanf(buffer.c_str(),"%i",&tmp); 
                        switch(index)
                        {
                            case 0 :
                                N = tmp;
                                DataTable = new int[tmp];
                                break;
                            case 1 :
                                R = tmp;
                                break;
                            case 2 :
                                D = tmp;
                                break;
                            default :
                                DataTable[index-3] = tmp;
                                break;
                        }
                        buffer="";
                        index++;
                    }    
                }
            }
            else
                if(buffer!="")
                {
                    sscanf(buffer.c_str(),"%i",&tmp);
                    DataTable[index-3] = tmp;
                }
        } 
        while (c != EOF);
    fclose (textfile);
    }
    return true;
}

/**
 * Charge le fichier de données à rechercher
 * @param address Adresse du fichier à charger
 * @return True si le fichier est valide
 */
bool Testing::LoadT2(const char* address)
{
    FILE * textfile;
    char c;
    int index=0;
    int tmp;
    string buffer="";
    
    textfile = fopen (address,"r");
    if (textfile == NULL)
    {
        perror ("Error opening file");
        return false;
    }
    else 
    {
        do 
        {
            c = fgetc (textfile);
            if(c != EOF)
            {
                if(c>='0'&& c<='9')
                {
                    buffer+=c;
                }
                else
                {
                    if(buffer!="")
                    {
                        sscanf(buffer.c_str(),"%i",&tmp); 
                        switch(index)
                        {
                            case 0 :
                                K = tmp;
                                SearchTable = new int[tmp];
                                break;
                   
                            default :
                                SearchTable[index-1] = tmp;
                                break;
                        }
                        buffer="";
                        index++;
                    }    
                }
            }
            else
                if(buffer!="")
                {
                    sscanf(buffer.c_str(),"%i",&tmp);
                    SearchTable[index-1] = tmp;
                }
        } 
        while (c != EOF);
    fclose (textfile);
    }
    return true;
}

/**
 * Sauvegarder les résultats et statistiques dans un fichier
 * @param address Nom du fichier à créer
 */
void Testing::SaveT3(const char* address)
{
    FILE * textfile;
    string alg;  
    textfile = fopen (address,"w");
    
    if(textfile)
    {
        
        switch(algo)
        {
            case HASH_SHORT: 
            case HASH_LONG:
            {    
                alg = "Table de hachage";
            }    
            break;
                
            case TREE_SHORT: 
            case TREE_LONG:
            {
                alg = "Arbre Binaire";
            }
            break;    
                
            case SEQ_SHORT: 
            case SEQ_LONG:
            {
                alg = "Recherche sequencielle";
            }
            break;
                
            case BIN_SHORT:
            case BIN_LONG:
            {    
                alg = "Recherche binaire";
            }
            break;
            
            case OPTIMIZE_SHORT:
            case OPTIMIZE_LONG:
            {
                alg = "Recherche optimisee";
            }    
            break;
        }
        //Stats methodeTri
        fprintf(textfile,"Algorithme de recherche = %s\nAlgorithme de tri = %s\n\n",alg.c_str(),methodeTri.c_str());
        fprintf(textfile,"N=%i\nR=%i\nD=%i\n\n",N,R,D);
        fprintf(textfile,"K=%i\nNBRE DE DONNEES TROUVEES = %i\n\n",K,count);
        //T1
        for(int i =0; i<(N-1);i++)
            fprintf(textfile,"%i\t",DataTable[i]);
        fprintf(textfile,"%i\n\n",DataTable[N-1]);
        //T2
        for(int i =0; i<(K-1);i++)
            fprintf(textfile,"%i\t",SearchTable[i]);
        fprintf(textfile,"%i\n\n",SearchTable[K-1]);
        //T3
        for(int i =0; i<(K-1);i++)
            fprintf(textfile,"%i\t",ResultTable[i]);
        fprintf(textfile,"%i",ResultTable[K-1]);    
    }
    
    fclose(textfile);
}

/**
 * Fonction à appeler pour configurer les tests
 */
void Testing::EnterConfig(void)
{
    //Enter data type : auto or load
        //if auto
            //N
            //R
            //D
        //if load
            //FileName
    //Enter search type : manual or file
        //if load
            //FileName
            //output filename
    //Enter algo type
    SetData();
    SetSearch();
    SetOutputFileAddress();
    SetAlgo();  
}

/**
 * Configure comment les données sont chargées
 */
void Testing::SetData(void)
{
    char c;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the type of data to test(0=auto; 1=load): ";
        cin >> c;
        if(cin.good())
        {
            switch(c)
            {
                case '0':
                    cmd = AUTO_SHORT;
                    SetNRD();
                    exit = true;
                    break;
                case '1':
                    cmd = LOAD_SHORT;
                    SetDataFileAddress();
                    exit = true;
                    break;
                default :
                    cout << "Wrong input\n\r";
                    break;
            }
        }
        else
        {
            cout << "Wrong input\n\r";
        }
        cin.ignore();
        cin.clear();
    }    
}

/**
 * Configure N, R et D
 */
void Testing::SetNRD(void)
{
    int value;
    bool exit;
    
    cout << "Enter auto config variable\n\r";
    for(int i=0; i<3;i++)
    {    
        switch(i)
        {
            case 0 :
                cout << "N = ";
                break;
            case 1 :
                cout << "R = ";
                break;
            case 2 :
                cout << "D = ";
                break;
                
        }
        exit = false;
        while(!exit)
        {
            cin >> value;
            if(cin.good())
            {
                if(value>=0)
                {
                    switch(i)
                    {
                        case 0 :
                        {
                            if(value>=1)
                            {
                                N = value;
                                exit = true;
                            }
                            else
                                cout << "Wrong value (N must be greater than 0)\n\rN= ";
                                
                        }
                            break;
                        case 1 :
                        {
                            if(value>=N)
                            {
                                R = value;
                                exit = true;
                            }
                            else    
                                cout << "Wrong value (R must be equal or greater than N)\n\rR= ";
                        }
                            break;
                        case 2 :
                        {
                            if(value<=100)
                            {
                                D = value;
                                exit = true;
                            }   
                            else
                                cout << "Wrong value (D must be between 0 and 100)\n\rD= ";
                        }
                            break;
                    }  
                }
                else
                {
                    cout << "Wrong value (must be greater or equal to 0)\n\r";
                }
            }
            else
            {
                cout << "Wrong value (must be a valid integer)\n\r";
                cin.clear();
                cin.ignore();
            }
                   
        }
    }
    cout << "N = " << N << " R = " << R << " D = " << D << endl;
    //Generate Values
    DataTable = new int[N];
    GenererDonnees(DataTable, N , R, D);
    //printIntArray(DataTable,N);
}


void Testing::SetDataFileAddress(void)
{
    string str;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the address of the data file: ";
        cin >> str;
        if(cin.good())
        {
            if(LoadT1(str.c_str()))
            {
                cout << "N = " << N << " R = " << R << " D = " << D << endl;
                exit = true;
            }
        }
        else
        {
            cout << "Wrong input\n\r";
            cin.clear();
            cin.ignore();
        }
    }
}

void Testing::SetSearch(void)
{
    char c;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the type of search to use (0=manual; 1=load): ";
        cin >> c;
        if(cin.good())
        {
            switch(c)
            {
                case '0':
                    if(cmd==AUTO_SHORT)
                        cmd = MANUAL_AUTO_SHORT;
                    else
                        cmd = MANUAL_LOAD_SHORT;
                    exit = true;
                    break;
                case '1':
                    SetSearchFileAddress();
                    exit = true;
                    break;
                default :
                    cout << "Wrong input\n\r";
                    break;
            }
        }
        else
        {
            cout << "Wrong input\n\r";
        }
        cin.clear();
        cin.ignore();
    }
}

/**
 * Mettre l'adresse pour le fichier des requetes
 */
void Testing::SetSearchFileAddress(void)
{
    string str;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the address of the search file: ";
        cin >> str;
        if(cin.good())
        {
            if(LoadT2(str.c_str()))
            {
                cout << "K = " << K << endl;
                ResultTable = new int[K];
                exit = true;
            }
        }
        else
        {
            cout << "Wrong input\n\r";
        }
        //cin.clear();
        //cin.ignore();
        
    }
}

/**
 * Mettre l'adresse du fichier des statistiques à créer/modifier
 */
void Testing::SetOutputFileAddress(void)
{
    string str;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the address of the stats file: ";
        cin >> str;
        if(cin.good())
        {
            outputFile=str;
            exit = true;
        }
        else
        {
            cout << "Wrong input\n\r";
        }
    }
}

/**
 * Choix de l'algorithme
 */
void Testing::SetAlgo(void)
{
    char c;
    bool exit =false;
    while(!exit)
    {
        cout << "Enter the type of algorithm to use :\n\r";
        cout << "0=sequencial" << endl;
        cout << "1=hash table" << endl;
        cout << "2=binary" << endl;
        cout << "3=tree" << endl;
        cout << "4=optimized" << endl;
        cin >> c;
        if(cin.good())
        {
            switch(c)
            {
                case '0':
                    algo =SEQ_SHORT;
                    exit = true;
                    break;
                case '1':
                    algo = HASH_SHORT;
                    exit = true;
                    break;
                case '2':
                    algo = BIN_SHORT;
                    exit = true;
                    break;
                case '3':
                    algo = TREE_SHORT;
                    exit = true;
                    break;
                case '4':
                    algo = OPTIMIZE_SHORT;
                    exit = true;
                    break;
                default :
                    cout << "Wrong input\n\r";
                    break;
            }
        }
        else
        {
            cout << "Wrong input\n\r";
        }
        cin.clear();
        cin.ignore();
    }
}

/**
 * Démarrer le test
 */
void Testing::StartTest(void)
{
    switch(cmd)
    {
        case AUTO_SHORT:
        //case AUTO_LONG:
        case LOAD_SHORT:
        //case LOAD_LONG:
            AutoRequest();
            break;
            
        case MANUAL_AUTO_SHORT:
        //case MANUAL_AUTO_LONG:
        case MANUAL_LOAD_SHORT:
        //case MANUAL_LOAD_LONG:
            ManualRequest();
            break;
    }
}

/**
 * Si les requêtes viennent d'un fichier 
 */
void Testing::AutoRequest(void)
{
    count=0;
    switch(algo)
    {
        case HASH_SHORT: 
        case HASH_LONG:
        {    
            cout << "\n\r" << "HASH TABLE" << "\n\n\r";

            hashH hashy(N);
            for(int i = 0; i < N; i++)
            {
                hashy.AddItem(DataTable[i],i);
            }
            for(int i =0; i<K; i++)
            {
                ResultTable[i] = hashy.RechercheHash(SearchTable[i]);
                if(ResultTable[i]!=-1)
                    count++;
            }
        }    
        break;

        case TREE_SHORT: 
        case TREE_LONG:
        {
            cout << "\n\r" << "TREE" << "\n\n\r";
            BinaryTree bin;
            for(int i =0; i<N; i++)
            {
                bin.addnode(DataTable[i],i);
            }
            for(int i =0; i<K; i++)
            {
                ResultTable[i] = bin.findNode(SearchTable[i]);
                if(ResultTable[i]!=-1)
                    count++;
            }
        }

        break;    

        case SEQ_SHORT: 
        case SEQ_LONG:
        {
            cout << "\n\r" << "SEQUENTIAL" << "\n\n\r";
            for(int i =0; i<K; i++)
            {
                ResultTable[i] = RechercheSequentielle(DataTable,SearchTable[i],N);
                if(ResultTable[i]!=-1)
                    count++;
            }
        }
        break;

        case BIN_SHORT:
        case BIN_LONG:
        {    
            int BigDataTable[N][2];
            int i;
            for (i = 0; i < N; i++)
            {
                BigDataTable[i][0] = DataTable[i]; // Premiere rangee = cle
                BigDataTable[i][1] = i; // Deuxieme rangee = position dans la liste non triee
            }

            cout << "\n\r" << "BINARY" << "\n\n\r";
            
            if(D==0 || (D<5 && N<2000))
            {
                methodeTri = "Tri par Insertion";
                TriParInsertion(BigDataTable,N);
            }
            else if(R<1000000)
            {
                int nbChiffre;
                nbChiffre=(int)log10(R)+1;
                methodeTri = "Tri par Base";
                TriParBase(BigDataTable,N,nbChiffre);
            }
            else
            {
                methodeTri = "Tri par Fusion";
                TriParFusion(BigDataTable, 0, N-1);
            }

            for(int i =0; i<K; i++)
            {
                ResultTable[i] = RechercheBinaire(BigDataTable,SearchTable[i],N);
                if(ResultTable[i]!=-1)
                    count++;
            }
        }
        break;
        case OPTIMIZE_SHORT:
        case OPTIMIZE_LONG:
        {
            cout << "\n\r" << "OPTIMIZE" << "\n\n\r";
            InitRechercheOptimisee(DataTable,N, R, D, &methodeTri);
            for(int i =0; i<K; i++)
            {
                ResultTable[i] = RechercheOptimisee(DataTable,SearchTable[i],N, R, D);
                if(ResultTable[i]!=-1)
                    count++;
            }
        }  
    }
    printf("K = %i, Count = %i\n\n\r",K,count);
    SaveT3(outputFile.c_str());
}

/**
 * Si les requêtes sont entrées manuellement
 */
void Testing::ManualRequest(void)
{
    int value = 0;
    K=0;
    count=0;
    vector<int> search;
    vector<int> result;
    
    switch(algo)
    {
        case HASH_SHORT: 
        case HASH_LONG:
        {    
            cout << "\n\r" << "HASH TABLE" << "\n\n\r";

            hashH hashy(N);
            for(int i = 0; i < N; i++)
            {
                hashy.AddItem(DataTable[i],i);
            }

            while(value>=0)
            {
                cout << "Enter a value to search (or negative value to quit): ";
                cin >> value;
                if(cin.good())
                {
                    if(value>=0)
                    {
                        K++;
                        search.push_back(value);
                        result.push_back(hashy.RechercheHash(value));
                        if(result.back()!=-1)
                            count++;
                        cout << "Value :" << value << " is found in index : "<< result.back() << endl;
                    }
                }
                else
                {
                    cout << "Wrong input\n\r";
                }
                cin.clear();
                cin.ignore();

            }
        }    
        break;

        case TREE_SHORT: 
        case TREE_LONG:
        {
            cout << "\n\r" << "TREE" << "\n\n\r";
            BinaryTree bin;
            for(int i =0; i<N; i++)
            {
                bin.addnode(DataTable[i],i);
            }

            while(value>=0)
            {
                cout << "Enter a value to search (or negative value to quit): ";
                cin >> value;
                if(cin.good())
                {
                    if(value>=0)
                    {
                        K++;
                        search.push_back(value);
                        result.push_back(bin.findNode(value));
                        if(result.back()!=-1)
                            count++;
                        cout << "Value :" << value << " is found in index : "<< result.back() << endl;
                    }
                }
                else
                {
                    cout << "Wrong input\n\r";
                }
                cin.clear();
                cin.ignore();
            }
        }
        break;    

        case SEQ_SHORT: 
        case SEQ_LONG:
        {
            cout << "\n\r" << "SEQ" << "\n\n\r";

            while(value>=0)
            {
                cout << "Enter a value to search (or negative value to quit): ";
                cin >> value;
                if(cin.good())
                {
                    if(value>=0)
                    {
                        K++;
                        search.push_back(value);
                        result.push_back(RechercheSequentielle(DataTable,value,N));
                        if(result.back()!=-1)
                            count++;
                        cout << "Value :" << value << " is found in index : "<< result.back() << endl;
                    }
                }
                else
                {
                    cout << "Wrong input\n\r";
                }
                cin.clear();
                cin.ignore();
            }
        }
        break;

        case BIN_SHORT:
        case BIN_LONG:
        {    
            int BigDataTable[N][2];
            int i;
            for (i = 0; i < N; i++)
            {
                BigDataTable[i][0] = DataTable[i]; // Premiere rangee = cle
                BigDataTable[i][1] = i; // Deuxieme rangee = position dans la liste non triee
            }

            cout << "\n\r" << "BINARY" << "\n\n\r";
            if(D==0 || (D<5 && N<2000))
            {
                methodeTri = "Tri par Insertion";
                TriParInsertion(BigDataTable,N);
            }
            else if(R<1000000)
            {
                int nbChiffre;
                nbChiffre=(int)log10(R)+1;
                methodeTri = "Tri par Base";
                TriParBase(BigDataTable,N,nbChiffre);
            }
            else
            {
                methodeTri = "Tri par Fusion";
                TriParFusion(BigDataTable, 0, N-1);
            }

            while(value>=0)
            {
                cout << "Enter a value to search (or negative value to quit): ";
                cin >> value;
                if(cin.good())
                {
                    if(value>=0)
                    {
                        K++;
                        search.push_back(value);
                        result.push_back(RechercheBinaire(BigDataTable,value,N));
                        if(result.back()!=-1)
                            count++;
                        cout << "Value :" << value << " is found in index : "<< result.back() << endl;
                    }
                }
                else
                {
                    cout << "Wrong input\n\r";
                }
                cin.clear();
                cin.ignore();
            }
        }
        break;
        case OPTIMIZE_SHORT:
        case OPTIMIZE_LONG:
        {
            
            
            cout << "\n\r" << "OPTIMIZE" << "\n\n\r";
            InitRechercheOptimisee(DataTable,N, R, D, &methodeTri);
            while(value>=0)
            {
                cout << "Enter a value to search (or negative value to quit): ";
                cin >> value;
                if(cin.good())
                {
                    if(value>=0)
                    {
                        K++;
                        search.push_back(value);
                        result.push_back(RechercheOptimisee(DataTable,value,N, R, D));
                        if(result.back()!=-1)
                            count++;
                        cout << "Value :" << value << " is found in index : "<< result.back() << endl;
                    }
                }
                else
                {
                    cout << "Wrong input\n\r";
                }
                cin.clear();
                cin.ignore();
            }
        }
        break;  
    }
    SearchTable = &search[0];
    ResultTable = &result[0];
    printf("K = %i, Count = %i\n\n\r",K,count);
    SaveT3(outputFile.c_str());
}